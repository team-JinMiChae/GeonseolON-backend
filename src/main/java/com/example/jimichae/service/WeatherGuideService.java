package com.example.jimichae.service;

import java.net.URI;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import com.example.jimichae.config.WeatherGuideProperties;
import com.example.jimichae.dto.GetBaseDateTime;
import com.example.jimichae.dto.response.KakaoMapApiResponse;
import com.example.jimichae.dto.response.WeatherApiResponse;
import com.example.jimichae.dto.response.WeatherInfoResponse;
import com.example.jimichae.entity.WeatherCategory;
import com.example.jimichae.entity.WeatherType;
import com.example.jimichae.repository.WeatherGuideCacheRepository;

@Service
public class WeatherGuideService {
	private final WeatherGuideProperties weatherGuideProperties;
	private final RestTemplate restTemplate = new RestTemplate();
	private final WeatherGuideCacheRepository weatherGuideCacheRepository;
	private final List<Integer> times = Arrays.asList(2, 5, 8, 11, 14, 17, 20, 23);

	public WeatherGuideService(WeatherGuideProperties weatherGuideProperties, WeatherGuideCacheRepository weatherGuideCacheRepository) {
		this.weatherGuideProperties = weatherGuideProperties;
		this.weatherGuideCacheRepository = weatherGuideCacheRepository;
	}

	public WeatherInfoResponse getWeatherGuide(int latitude, int longitude) {
		String encodedDataType = URLEncoder.encode("JSON", StandardCharsets.UTF_8);
		String regionName =getRegionName(latitude, longitude);
		LocalDateTime koreaDateTime = LocalDateTime.now();
		String koreaDate = koreaDateTime.format(DateTimeFormatter.ofPattern("yyyyMMdd"));
		String onTime = koreaDateTime.withMinute(0).format(DateTimeFormatter.ofPattern("HHmm"));
		if (weatherGuideCacheRepository.existsByWeatherInfo(koreaDate, onTime, regionName)) {
			return weatherGuideCacheRepository.getWeatherInfo(koreaDate, onTime, regionName);
		}
		GetBaseDateTime baseDateTime = getBaseDateTime(koreaDateTime);
		URI uri = UriComponentsBuilder.fromUriString("https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst")
			.queryParam("serviceKey", weatherGuideProperties.getApiKey())
			.queryParam("pageNo", 1)
			.queryParam("numOfRows", 60)
			.queryParam("dataType", encodedDataType)
			.queryParam("base_date", URLEncoder.encode(baseDateTime.baseDate(), StandardCharsets.UTF_8))
			.queryParam("base_time", URLEncoder.encode(baseDateTime.baseTime(), StandardCharsets.UTF_8))
			.queryParam("nx", latitude)
			.queryParam("ny", longitude)
			.build(true)
			.encode(StandardCharsets.UTF_8)
			.toUri();

		WeatherApiResponse response = restTemplate.getForObject(uri, WeatherApiResponse.class);
		if (response!=null&&response.getResponse() != null && response.getResponse().getBody() != null && response.getResponse().getBody().getItems() != null) {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
			LocalDateTime nowDateTime = LocalDateTime.parse(baseDateTime.baseDate() + baseDateTime.baseTime(), formatter);
			Map<String,Map<String,String>> map = response.getResponse().getBody().getItems().getItem().stream().filter(item -> {
				LocalDateTime fcstDateTime = LocalDateTime.parse(item.getFcstDate() + item.getFcstTime(), formatter);
				return !fcstDateTime.isBefore(koreaDateTime.withMinute(0).withSecond(0).withNano(0)) && fcstDateTime.isBefore(nowDateTime.plusHours(4).plusMinutes(30));
			})
				.collect(Collectors.groupingBy(
					item -> item.getFcstDate() + " " + item.getFcstTime(),
					Collectors.toMap(
						WeatherApiResponse.Item::getCategory,
						WeatherApiResponse.Item::getFcstValue
					)
				));
			String[] tmxAndTmn;
			if(weatherGuideCacheRepository.existsByTmxAndTmn(koreaDate,regionName)){
				tmxAndTmn = weatherGuideCacheRepository.getRegionTMXAndTMN(koreaDate,regionName);
			}else {
				tmxAndTmn = getTmxAndTmn(koreaDateTime,latitude,longitude);
				weatherGuideCacheRepository.saveTmxAndTmn(koreaDate,regionName, tmxAndTmn);
			}
			List<WeatherInfoResponse> list = map.entrySet().stream().map(entry -> {
					Map<String, String> timeMap = entry.getValue();
					return getWeatherInfoResponse(entry.getKey(), timeMap, tmxAndTmn, regionName);
				})
				.sorted(Comparator.comparing(WeatherInfoResponse::getFcstTime))
				.toList();

			list.forEach(it-> {
				weatherGuideCacheRepository.saveWeatherInfo(it.getFcstDate(),it.getFcstTime(),regionName,it);
			});
			return list.getFirst();
		}

		return WeatherInfoResponse.builder().fcstTime(koreaDateTime.withMinute(0).format(DateTimeFormatter.ofPattern("HHmm")))
			.fcstDate(koreaDateTime.format(DateTimeFormatter.ofPattern("yyyyMMdd")))
			.type(WeatherType.NO_DATA)
			.build();
	}

	private GetBaseDateTime getBaseDateTime(LocalDateTime koreaDateTime) {

		int currentHour = koreaDateTime.minusMinutes(10).getHour();
		int targetHour = -1;
		for (int i = times.size() - 1; i >= 0; i--) {
			if (currentHour > times.get(i)) {
				targetHour = times.get(i);
				break;
			}
		}

		LocalDate targetDate = koreaDateTime.toLocalDate();
		if (currentHour <= 2 || targetHour == -1) {
			targetHour = 23;
			targetDate = targetDate.minusDays(1);
		}

		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
		DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HHmm");

		String formattedDate = targetDate.format(formatter);
		String formattedTime = LocalTime.of(targetHour, 0).format(timeFormatter);
		return new GetBaseDateTime(formattedDate, formattedTime);
	}

	private WeatherInfoResponse getWeatherInfoResponse(String fcstDateTime,Map<String, String> timeMap, String[] tmxAndTmn, String regionName) {
			WeatherType type =  WeatherType.NO_DATA;
			String pty = timeMap.get(WeatherCategory.PTY.name());
			switch (pty) {
				case "0" -> {
					if (Double.parseDouble(tmxAndTmn[0]) >= 33){
						type = WeatherType.HOT;
					} else if (Double.parseDouble(timeMap.get(WeatherCategory.WSD.name()))>=4.0){
						type = WeatherType.WIND;
					} else if (timeMap.get(WeatherCategory.SKY.name()).equals("4")){
						type = WeatherType.CLOUDY;
					} else {
						type = WeatherType.CLEAR_DAY;
					}
				}
				case "1", "4" -> type = WeatherType.RAIN;
				case "2" -> type = WeatherType.RAIN_SNOW;
				case "3" -> type = WeatherType.SNOWY;
			}
			String contents = getContents(type, timeMap);
			String[] splitDateTime = fcstDateTime.split(" ");
		return WeatherInfoResponse.builder().pop(getWeatherCategoryValue(timeMap, WeatherCategory.POP))
			.reh(getWeatherCategoryValue(timeMap, WeatherCategory.REH))
			.tmp(getWeatherCategoryValue(timeMap, WeatherCategory.TMP))
			.tmx(tmxAndTmn[0])
			.tmn(tmxAndTmn[1])
			.fcstTime(splitDateTime[1])
			.fcstDate(splitDateTime[0])
			.type(type)
			.regionName(regionName)
			.weatherMent(contents)
			.build();
	}

	private String getWeatherCategoryValue(Map<String, String> timeMap, WeatherCategory category) {
		return timeMap.getOrDefault(category.name(),null);
	}

	private String getContents(WeatherType type, Map<String, String> timeMap) {
				StringBuilder advice = new StringBuilder("Ïò§ÎäòÏùò ÏûëÏóÖ ÌòÑÏû• ÎÇ†Ïî® ÏïàÎÇ¥\n\n");

				String pcp = timeMap.getOrDefault(WeatherCategory.PCP.name(), null);
				String sno = timeMap.getOrDefault(WeatherCategory.SNO.name(), null);
				String tmp = timeMap.getOrDefault(WeatherCategory.TMP.name(), null);
				String reh = timeMap.getOrDefault(WeatherCategory.REH.name(), null);
				String wsd = timeMap.getOrDefault(WeatherCategory.WSD.name(), null);

				// ÌïòÎäò ÏÉÅÌÉú
				switch (type) {
					case WeatherType.RAIN: {
						advice.append(String.format("üåßÔ∏è ÎπÑÍ∞Ä ÎÇ¥Î¶¨Î©∞, ÏãúÍ∞ÑÎãπ Í∞ïÏàòÎüâÏùÄ %sÏûÖÎãàÎã§.", pcp));
						advice.append("ÎØ∏ÎÅÑÎüº ÏÇ¨Í≥†ÏôÄ Í∞êÏ†Ñ ÏúÑÌóòÏóê Ïú†ÏùòÌïòÏÑ∏Ïöî.\n");
						break;
					}
					case WeatherType.SNOWY: {
						advice.append(String.format("‚ùÑÔ∏è ÎààÏù¥ %s ÎÇ¥Î¶¥ ÏòàÏ†ïÏûÖÎãàÎã§.", sno));
						advice.append("Ï†úÏÑ§ ÏûëÏóÖ Î∞è ÎØ∏ÎÅÑÎüº ÏÇ¨Í≥† ÏòàÎ∞© Ï°∞ÏπòÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.\n");
						break;
					}
					case WeatherType.LIGHTNING:
						advice.append("‚ö°Ô∏èÏ≤úÎë•Î≤àÍ∞úÍ∞Ä ÎèôÎ∞òÎêú ÎÇ†Ïî®ÏûÖÎãàÎã§.");
						advice.append("ÏïºÏô∏ Í≥†ÏÜå ÏûëÏóÖÍ≥º Ï†ÑÍ∏∞ ÏûëÏóÖÏùÄ ÏµúÎåÄÌïú ÌîºÌï¥Ï£ºÏÑ∏Ïöî.\n");
						break;
					case WeatherType.WIND:
						advice.append(String.format("üí® Í∞ïÌïú Î∞îÎûåÏù¥ Î∂àÍ≥† ÏûàÏäµÎãàÎã§ (ÌíçÏÜç %sm/s).", wsd));
						advice.append("Í≥†ÏÜå Ïû•ÎπÑÎÇò ÌÅ¨Î†àÏù∏ ÏÇ¨Ïö© Ï†Ñ ÏïàÏ†Ñ Ï†êÍ≤ÄÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.\n");
						break;
					case WeatherType.CLEAR_DAY:
						advice.append("‚òÄÔ∏è ÎßëÍ≥† ÏæåÏ≤≠Ìïú ÎÇ†Ïî®ÏûÖÎãàÎã§.\n");
						break;
					case WeatherType.CLOUDY:
						advice.append("‚òÅÔ∏è ÌùêÎ¶∞ ÎÇ†Ïî®Î°ú ÏãúÏïº ÌôïÎ≥¥Ïóê Ï£ºÏùòÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.\n");
						break;
					case WeatherType.RAIN_SNOW:
						advice.append(String.format("üå®Ô∏è ÎπÑÏôÄ ÎààÏù¥ ÏÑûÏó¨ ÎÇ¥Î¶¥ ÏòàÏ†ïÏûÖÎãàÎã§ (Í∞ïÏàòÎüâ %s, Ïã†Ï†ÅÏÑ§ %s).", pcp, sno));
						advice.append("Î∞îÎã• ÎØ∏ÎÅÑÎüºÍ≥º Í∏∞Í≥Ñ Í≤∞Îπô Î™®ÎëêÏóê ÎåÄÎπÑÌï¥Ïïº Ìï©ÎãàÎã§.\n");
						break;
					case WeatherType.HOT:
						advice.append("üî• Î¨¥ÎçîÏö¥ ÎÇ†Ïî®ÏûÖÎãàÎã§.\n");
						break;
				}

				// Í∏∞Ïò®
				if (tmp!=null) {
					double newTmp = Double.parseDouble(tmp);
					if (newTmp >= 30) {
						advice.append(String.format("üå°Ô∏è ÌòÑÏû¨ Í∏∞Ïò®ÏùÄ %s‚ÑÉÎ°ú Îß§Ïö∞ Îç•ÏäµÎãàÎã§.\n", tmp));
						advice.append("Ïó¥ÏÇ¨Î≥ë ÏòàÎ∞©ÏùÑ ÏúÑÌï¥ Í∑∏Îäò Ìú¥ÏãùÍ≥º ÏàòÎ∂Ñ ÏÑ≠Ï∑®Î•º ÏûäÏßÄ ÎßàÏÑ∏Ïöî.\n");
					} else if (newTmp <= 0) {
						advice.append(String.format("üå°Ô∏è ÌòÑÏû¨ Í∏∞Ïò®ÏùÄ %s‚ÑÉÎ°ú Îß§Ïö∞ Ï∂•ÏäµÎãàÎã§.\n", tmp));
						advice.append("Î∞©ÌïúÎ≥µ Ï∞©Ïö© Î∞è Ïû•ÎπÑ Í≤∞Îπô Ïó¨Î∂ÄÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.\n");
					}
				}

				// ÏäµÎèÑ
				if (reh!=null){
					double newReh = Double.parseDouble(reh);
					if (newReh >= 80) {
						advice.append(String.format("üíß ÌòÑÏû¨ ÏäµÎèÑÎäî %s%%Î°ú Îß§Ïö∞ ÎÜíÏäµÎãàÎã§.\n", reh));
						advice.append("ÏäµÍ∏∞ÏôÄ Í≤∞Î°úÎ°ú Ïù∏Ìïú Ïû•ÎπÑ Í≤∞ÎπôÏóê Ï£ºÏùòÌïòÏÑ∏Ïöî.\n");
					} else if (newReh <= 30) {
						advice.append(String.format("üíß ÌòÑÏû¨ ÏäµÎèÑÎäî %s%%Î°ú Îß§Ïö∞ ÎÇÆÏäµÎãàÎã§.\n", reh));
						advice.append("Ï†ïÏ†ÑÍ∏∞ Î∞úÏÉùÏóê Ï£ºÏùòÌïòÏÑ∏Ïöî.\n");
					}
				}

				if (wsd!=null){
					double newWsd = Double.parseDouble(wsd);
					if (type!=WeatherType.WIND&&newWsd >= 4.0) {
						advice.append(String.format("üå¨Ô∏è Î∞îÎûåÏù¥ Îß§Ïö∞ Í∞ïÌïòÍ≤å Î∂ëÎãàÎã§ (%sm/s). ÎÇôÌïòÎ¨º Î∞è ÎπÑÏÇ∞Î¨º ÏÇ¨Í≥†Ïóê Ï£ºÏùòÌïòÏÑ∏Ïöî.\n", wsd));
					}
				}

				advice.append("\n‚õëÔ∏è Ïò§ÎäòÎèÑ ÏïàÏ†ÑÌïú ÏûëÏóÖ ÎêòÏãúÍ∏∏ Î∞îÎûçÎãàÎã§. Ïû•ÎπÑ Ï†êÍ≤ÄÍ≥º ÏûëÏóÖ Ï†Ñ ÍµêÏú°ÏùÑ ÏûäÏßÄ ÎßàÏÑ∏Ïöî.\n");

				return advice.toString();
			}

			private String[] getTmxAndTmn(LocalDateTime dateTime, int latitude, int longitude) {
				String encodedDataType = URLEncoder.encode("JSON", StandardCharsets.UTF_8);
				String baseDate = dateTime.minusDays(1).format(DateTimeFormatter.ofPattern("yyyyMMdd"));
				URI uri = UriComponentsBuilder.fromUriString("https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst")
					.queryParam("serviceKey", weatherGuideProperties.getApiKey())
					.queryParam("pageNo", 1)
					.queryParam("numOfRows", 15*16)
					.queryParam("dataType", encodedDataType)
					.queryParam("base_date", URLEncoder.encode(baseDate, StandardCharsets.UTF_8))
					.queryParam("base_time", URLEncoder.encode("2300", StandardCharsets.UTF_8))
					.queryParam("nx", latitude)
					.queryParam("ny", longitude)
					.build(true)
					.encode(StandardCharsets.UTF_8)
					.toUri();

				WeatherApiResponse response = restTemplate.getForObject(uri, WeatherApiResponse.class);

				if (response!=null&&response.getResponse() != null && response.getResponse().getBody() != null && response.getResponse().getBody().getItems() != null) {
					Map<String,Map<String,String>> map = response.getResponse().getBody().getItems().getItem().stream().collect(Collectors.groupingBy(
							WeatherApiResponse.Item::getFcstTime,
							Collectors.toMap(
								WeatherApiResponse.Item::getCategory,
								WeatherApiResponse.Item::getFcstValue
							)
						));
					String tmn = map.get("0600").get(WeatherCategory.TMN.name());
					String tmx = map.get("1500").get(WeatherCategory.TMX.name());

					return new String[]{tmx,tmn};
			}
				return new String[]{null,null};
			}

			private String getRegionName(int latitude, int longitude) {
				HttpHeaders headers = new HttpHeaders();
				headers.set("Authorization", "KakaoAK " + weatherGuideProperties.getKakaoMapKey());
				HttpEntity<String> entity = new HttpEntity<>(headers);
				URI uri = UriComponentsBuilder.fromUriString("https://dapi.kakao.com/v2/local/geo/coord2regioncode")
					.queryParam("x", longitude)
					.queryParam("y", latitude)
					.build(true)
					.encode(StandardCharsets.UTF_8)
					.toUri();
				ResponseEntity<KakaoMapApiResponse> response = restTemplate.exchange(
					uri,
					HttpMethod.GET,
					entity,
					KakaoMapApiResponse.class
				);

				if (response.getBody() != null && response.getBody().getMeta() != null && response.getBody().getMeta().getTotal_count() > 0) {
					KakaoMapApiResponse.Document document = response.getBody().getDocuments()[0];
					return document.getRegion_1depth_name() + " " + document.getRegion_2depth_name();
				} else {
					return "ÌååÏïÖ Î∂àÍ∞Ä";
				}
			}
	}
